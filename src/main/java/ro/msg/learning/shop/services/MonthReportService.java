package ro.msg.learning.shop.services;

import lombok.RequiredArgsConstructor;
import lombok.val;
import org.springframework.stereotype.Service;
import ro.msg.learning.shop.repositories.OrderRepository;
import ro.msg.learning.shop.wrappers.QuantityTotalRevenueWrapper;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;


@Service
@RequiredArgsConstructor
public class MonthReportService {

    private final OrderRepository orderRepository;


    /**
     * map1<Date,(map2<Product,QuantityTotalRevenueWrapper)>>
     * map2: is a map in which the key is the product and the value is a QuantityTotalRevenueWrapper
     * that contains how much of that product was sold and what was the generated revenue
     * map1: is a map in which the key is a date and the value is a map containing every product sold in that date,
     * the quantity sold, and the total revenue generated by that product in that date
     */
    public Map<LocalDateTime, Map<Integer, QuantityTotalRevenueWrapper>> getProductQuantityTotalRevenueForEachProductSoldMappedByDate() {

        Map<LocalDateTime, Map<Integer, QuantityTotalRevenueWrapper>> dateProductMap = new HashMap<>();
        final val allOrders = orderRepository.findAllByIdGreaterThan(1000);
        allOrders.forEach(order -> {
            LocalDateTime orderDate = order.getOrderDate();
            if (dateProductMap.containsKey(orderDate)) {
                val productQuantityTotalRevenueWrapperMap = dateProductMap.get(orderDate);
                order.getOrderDetails().forEach(orderDetail -> {
                    final val product = orderDetail.getProduct();
                    final val quantity = orderDetail.getQuantity();
                    final val revenue = quantity * product.getPrice().intValue();
                    if (productQuantityTotalRevenueWrapperMap.containsKey(product.getId())) {
                        val quantityTotalRevenueWrapper = productQuantityTotalRevenueWrapperMap.get(product.getId());
                        quantityTotalRevenueWrapper.setQuantity(quantityTotalRevenueWrapper.getQuantity() + quantity);
                        quantityTotalRevenueWrapper.setTotalRevenue(quantityTotalRevenueWrapper.getTotalRevenue() + revenue);
                        productQuantityTotalRevenueWrapperMap.put(product.getId(), quantityTotalRevenueWrapper);
                    } else {
                        productQuantityTotalRevenueWrapperMap.put(product.getId(), new QuantityTotalRevenueWrapper(quantity, revenue));
                    }
                });


            } else {
                Map<Integer, QuantityTotalRevenueWrapper> productQuantityTotalRevenueWrapperMap = new HashMap<>();
                order.getOrderDetails().forEach(orderDetail -> {
                    final val product = orderDetail.getProduct();
                    final val quantity = orderDetail.getQuantity();
                    final val revenue = quantity * (product.getPrice()).intValue();
                    productQuantityTotalRevenueWrapperMap.put(product.getId(), new QuantityTotalRevenueWrapper(quantity, revenue));
                });
                dateProductMap.put(orderDate, productQuantityTotalRevenueWrapperMap);
            }

        });

        return dateProductMap;
    }


}

