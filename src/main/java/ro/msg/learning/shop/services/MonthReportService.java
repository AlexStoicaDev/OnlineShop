package ro.msg.learning.shop.services;

import lombok.RequiredArgsConstructor;
import lombok.val;
import org.springframework.stereotype.Service;
import ro.msg.learning.shop.repositories.OrderRepository;
import ro.msg.learning.shop.wrappers.QuantityTotalRevenueWrapper;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;


@Service
@RequiredArgsConstructor
public class MonthReportService {

    private final OrderRepository orderRepository;


    /**
     * map1<Date,(map2<Product,QuantityTotalRevenueWrapper)>>
     * <map2>
     * is a map in which the key is the product and the value is a QuantityTotalRevenueWrapper
     * that contains how much of that product was sold and what was the generated revenue
     * </map2>
     * <map1>
     * is a map in which the key is a date and the value is a map containing every product sold in that date,
     * the quantity sold, and the total revenue generated by that product in that date
     * </map1>
     */
    public Map<LocalDateTime, Map<Integer, QuantityTotalRevenueWrapper>> getProductQuantityTotalRevenueForEachProductSoldMappedByDate(LocalDateTime localDateTime1, LocalDateTime localDateTime2) {

        Map<LocalDateTime, Map<Integer, QuantityTotalRevenueWrapper>> dateProductMap = new HashMap<>();
        final val allOrders = orderRepository.findAllByOrderDateAfterAndOrderDateBefore(localDateTime1, localDateTime2);
        allOrders.forEach(order -> {
            LocalDateTime orderDate = order.getOrderDate();
            /*
            if the date is present in the map as a key, then we check if the
                products are contained in the second map.
             */

            if (dateProductMap.containsKey(orderDate)) {
                val productQuantityTotalRevenueWrapperMap = dateProductMap.get(orderDate);
                order.getOrderDetails().forEach(orderDetail -> {
                    final val product = orderDetail.getProduct();
                    final val quantity = orderDetail.getQuantity();
                    final val revenue = quantity * product.getPrice().intValue();
                    /*
                    if the product is present as a key, the quantity and total revenue are increased
                     */
                    if (productQuantityTotalRevenueWrapperMap.containsKey(product.getId())) {
                        val quantityTotalRevenueWrapper = productQuantityTotalRevenueWrapperMap.get(product.getId());
                        quantityTotalRevenueWrapper.setQuantity(quantityTotalRevenueWrapper.getQuantity() + quantity);
                        quantityTotalRevenueWrapper.setTotalRevenue(quantityTotalRevenueWrapper.getTotalRevenue() + revenue);
                        productQuantityTotalRevenueWrapperMap.put(product.getId(), quantityTotalRevenueWrapper);
                    }
                    /*
                     if the product is not present as a key, then a new entry is created for that product
                     */
                    else {
                        productQuantityTotalRevenueWrapperMap.put(product.getId(), new QuantityTotalRevenueWrapper(quantity, revenue));
                    }
                });


            }
              /*
            if the date is not present in the map as a key, then we create a new entry
             */
            else {
                /*
                this map key is a product and the values are a QuantityTotalRevenueWrapper that contains the quantity that was sold, and the total revenue
                 */
                Map<Integer, QuantityTotalRevenueWrapper> productQuantityTotalRevenueWrapperMap = new HashMap<>();
                order.getOrderDetails().forEach(orderDetail -> {
                    final val product = orderDetail.getProduct();
                    final val quantity = orderDetail.getQuantity();
                    final val revenue = quantity * (product.getPrice()).intValue();
                    productQuantityTotalRevenueWrapperMap.put(product.getId(), new QuantityTotalRevenueWrapper(quantity, revenue));
                });
                dateProductMap.put(orderDate, productQuantityTotalRevenueWrapperMap);
            }

        });

        return dateProductMap;
    }


}

